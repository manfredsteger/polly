import { storage } from "../storage";

const API_BASE_URL = 'https://app.pentest-tools.com/api/v2';

export interface PentestToolsConfig {
  apiToken: string;
  configuredViaEnv: boolean;
}

export interface PollyTargetInfo {
  configured: boolean;
  url?: string;
  targetId?: number;
  workspaceId?: number;
  lastSynced?: string;
  error?: string;
}

interface PentestTarget {
  id: number;
  name: string;
  type: 'hostname' | 'ip_address' | 'url';
  description?: string;
  workspace_id?: number;
}

interface ResultSummary {
  text?: string;
  critical?: number;
  high?: number;
  medium?: number;
  low?: number;
  info?: number;
}

interface ScanResult {
  id: string;
  status: string;
  progress?: number;
  target?: string;
  tool_id?: number;
  tool_name?: string;
  started_at?: string;
  finished_at?: string;
  findings_count?: number;
  result_summary?: ResultSummary;
}

interface Finding {
  id: string;
  title: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  description?: string;
  solution?: string;
  reference?: string;
  cvss_score?: number;
  cwe_id?: string;
  affected_url?: string;
}

interface ScanStartResponse {
  success: boolean;
  scan_id?: string;
  error?: string;
}

interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export const TOOL_IDS = {
  WEBSITE_SCANNER: 170,
  SUBDOMAIN_FINDER: 130,
  PORT_SCANNER: 140,
  NETWORK_SCANNER: 160,
  URL_FUZZER: 180,
  SQLI_SCANNER: 190,
  XSS_SCANNER: 200,
  WORDPRESS_SCANNER: 210,
  API_SCANNER: 220,
} as const;

export const TOOL_NAMES: Record<number, string> = {
  170: 'Website Vulnerability Scanner',
  130: 'Subdomain Finder',
  140: 'Port Scanner (TCP)',
  160: 'Network Vulnerability Scanner',
  180: 'URL Fuzzer',
  190: 'SQLi Scanner',
  200: 'XSS Scanner',
  210: 'WordPress Scanner',
  220: 'API Scanner',
};

export const SCAN_TYPES = {
  LIGHT: 'light',
  FULL: 'full_new',
  QUICK: 'quick',
} as const;

class PentestToolsService {
  private configCache: PentestToolsConfig | null = null;
  private configCacheTime: number = 0;
  private readonly CACHE_TTL = 30000; // 30 seconds cache

  async getConfig(): Promise<PentestToolsConfig> {
    // Check if ENV variable is set - it takes precedence
    const envToken = process.env.PENTEST_TOOLS_API_TOKEN || '';
    if (envToken) {
      return {
        apiToken: envToken,
        configuredViaEnv: true,
      };
    }

    // Check cache
    const now = Date.now();
    if (this.configCache && (now - this.configCacheTime) < this.CACHE_TTL) {
      return this.configCache;
    }

    // Load from database
    try {
      const setting = await storage.getSetting('pentest_tools_config');
      if (setting && setting.value) {
        const dbConfig = setting.value as { apiToken?: string };
        this.configCache = {
          apiToken: dbConfig.apiToken || '',
          configuredViaEnv: false,
        };
      } else {
        this.configCache = {
          apiToken: '',
          configuredViaEnv: false,
        };
      }
      this.configCacheTime = now;
      return this.configCache;
    } catch (error) {
      console.error('Failed to load Pentest-Tools config:', error);
      return {
        apiToken: '',
        configuredViaEnv: false,
      };
    }
  }

  clearConfigCache(): void {
    this.configCache = null;
    this.configCacheTime = 0;
  }

  private async getToken(): Promise<string> {
    const config = await this.getConfig();
    return config.apiToken || '';
  }

  private async getHeaders(): Promise<Record<string, string>> {
    return {
      'Authorization': `Bearer ${await this.getToken()}`,
      'Content-Type': 'application/json',
    };
  }

  async isConfigured(): Promise<boolean> {
    const config = await this.getConfig();
    return !!config.apiToken && config.apiToken.length > 0;
  }

  async testConnection(): Promise<{ success: boolean; message: string; account?: any }> {
    if (!(await this.isConfigured())) {
      return { success: false, message: 'API Token nicht konfiguriert' };
    }

    try {
      // Use /workspaces endpoint to verify API connection (documented in API schema)
      const response = await fetch(`${API_BASE_URL}/workspaces`, {
        method: 'GET',
        headers: await this.getHeaders(),
      });

      const responseText = await response.text();
      
      // Check if response is HTML (error page from API gateway/CDN)
      if (responseText.startsWith('<!DOCTYPE') || responseText.startsWith('<html')) {
        return { 
          success: false, 
          message: 'API nicht erreichbar - möglicherweise ungültiger Token oder Netzwerkproblem' 
        };
      }

      // Try to parse as JSON
      let data: any;
      try {
        data = JSON.parse(responseText);
      } catch (parseError) {
        return { 
          success: false, 
          message: `Ungültige API-Antwort: ${responseText.substring(0, 100)}` 
        };
      }

      if (!response.ok) {
        // Check for specific error codes
        if (response.status === 401 || response.status === 403) {
          return { 
            success: false, 
            message: 'Ungültiger API-Token - bitte prüfen Sie den Token in Ihrem Pentest-Tools Account' 
          };
        }
        return { 
          success: false, 
          message: `API Fehler: ${response.status} - ${data.message || data.error || 'Unbekannter Fehler'}` 
        };
      }

      // Extract workspace info if available
      const workspaces = data.data || data;
      const workspaceCount = Array.isArray(workspaces) ? workspaces.length : 0;

      return { 
        success: true, 
        message: 'Verbindung erfolgreich',
        account: { 
          workspaces: workspaceCount,
          info: workspaceCount > 0 ? `${workspaceCount} Workspace(s) gefunden` : 'Verbunden'
        }
      };
    } catch (error) {
      return { 
        success: false, 
        message: `Verbindungsfehler: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}` 
      };
    }
  }

  async startScan(
    targetId: number,
    toolId: number = TOOL_IDS.WEBSITE_SCANNER,
    scanType: string = SCAN_TYPES.LIGHT,
    options: Record<string, any> = {}
  ): Promise<ScanStartResponse> {
    if (!(await this.isConfigured())) {
      return { success: false, error: 'API Token nicht konfiguriert' };
    }

    try {
      const payload = {
        op: 'start_scan',
        tool_id: toolId,
        target_id: targetId,
        tool_params: {
          scan_type: scanType,
          follow_redirects: true,
          ...options
        }
      };

      console.log('[Pentest-Tools] Starting scan with payload:', JSON.stringify(payload));

      const response = await fetch(`${API_BASE_URL}/scans`, {
        method: 'POST',
        headers: await this.getHeaders(),
        body: JSON.stringify(payload),
      });

      const responseText = await response.text();
      console.log('[Pentest-Tools] Scan response:', response.status, responseText);

      if (!response.ok) {
        let errorMessage = `HTTP ${response.status}`;
        try {
          const errorData = JSON.parse(responseText);
          errorMessage = errorData.message || errorData.error || errorMessage;
        } catch (e) {}
        return { success: false, error: errorMessage };
      }

      const data = JSON.parse(responseText);
      return { 
        success: true, 
        scan_id: data.data?.id || data.id 
      };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unbekannter Fehler' 
      };
    }
  }

  async getScanStatus(scanId: string): Promise<ApiResponse<ScanResult>> {
    if (!(await this.isConfigured())) {
      return { success: false, error: 'API Token nicht konfiguriert' };
    }

    try {
      const response = await fetch(`${API_BASE_URL}/scans/${scanId}`, {
        method: 'GET',
        headers: await this.getHeaders(),
      });

      if (!response.ok) {
        const errorData = await response.json() as any;
        return { 
          success: false, 
          error: errorData.message || `HTTP ${response.status}` 
        };
      }

      const data = await response.json() as any;
      const scanData = data.data || data;
      
      return { 
        success: true, 
        data: {
          id: scanData.id,
          status: scanData.status,
          progress: scanData.progress,
          target: scanData.target,
          tool_id: scanData.tool_id,
          tool_name: TOOL_NAMES[scanData.tool_id] || `Tool ${scanData.tool_id}`,
          started_at: scanData.started_at,
          finished_at: scanData.finished_at,
          findings_count: scanData.findings_count,
        }
      };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unbekannter Fehler' 
      };
    }
  }

  async getScans(limit: number = 20, pollyOnly: boolean = true): Promise<ApiResponse<ScanResult[]>> {
    if (!(await this.isConfigured())) {
      return { success: false, error: 'API Token nicht konfiguriert' };
    }

    try {
      // Get all Polly-related target IDs (current + historical replit URLs)
      let pollyTargetIds: Set<number> = new Set();
      if (pollyOnly) {
        // Get current target
        const targetInfo = await this.getPollyTargetInfo();
        if (targetInfo.configured && targetInfo.targetId) {
          pollyTargetIds.add(targetInfo.targetId);
        }
        
        // Also find all targets that look like Replit URLs (for historical scans)
        const allTargets = await this.getAllPollyRelatedTargets();
        allTargets.forEach(id => pollyTargetIds.add(id));
      }

      const response = await fetch(`${API_BASE_URL}/scans?limit=${limit}`, {
        method: 'GET',
        headers: await this.getHeaders(),
      });

      if (!response.ok) {
        const errorData = await response.json() as any;
        return { 
          success: false, 
          error: errorData.message || `HTTP ${response.status}` 
        };
      }

      const data = await response.json() as any;
      
      // Filter to only Polly target scans if pollyOnly is true
      let rawScans = data.data || [];
      if (pollyOnly && pollyTargetIds.size > 0) {
        rawScans = rawScans.filter((scan: any) => pollyTargetIds.has(scan.target_id));
      }
      
      const scans = rawScans.map((scan: any) => {
        // Calculate total findings from result_summary
        const resultSummary = scan.result_summary || {};
        const findingsCount = (resultSummary.critical || 0) + 
                             (resultSummary.high || 0) + 
                             (resultSummary.medium || 0) + 
                             (resultSummary.low || 0) + 
                             (resultSummary.info || 0);
        
        return {
          id: String(scan.id),
          status: scan.status_name || scan.status || 'unknown',
          progress: scan.progress ?? undefined,
          target: scan.target_name || `Target ${scan.target_id}` || '',
          tool_id: scan.tool_id,
          tool_name: TOOL_NAMES[scan.tool_id] || `Tool ${scan.tool_id}`,
          started_at: scan.start_time || scan.started_at,
          finished_at: scan.end_time || scan.finished_at,
          findings_count: findingsCount > 0 ? findingsCount : undefined,
          result_summary: resultSummary,
        };
      });

      return { success: true, data: scans };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unbekannter Fehler' 
      };
    }
  }

  async getFindings(scanId: string): Promise<ApiResponse<Finding[]>> {
    if (!(await this.isConfigured())) {
      return { success: false, error: 'API Token nicht konfiguriert' };
    }

    try {
      // Try /scans/{id}/output endpoint first (main results endpoint)
      const response = await fetch(`${API_BASE_URL}/scans/${scanId}/output`, {
        method: 'GET',
        headers: await this.getHeaders(),
      });

      if (!response.ok) {
        const errorData = await response.json() as any;
        return { 
          success: false, 
          error: errorData.message || `HTTP ${response.status}` 
        };
      }

      const data = await response.json() as any;
      console.log('[Pentest-Tools] Raw output response:', JSON.stringify(data, null, 2).substring(0, 2000));
      
      // Parse findings from output - structure varies by tool
      let findings: Finding[] = [];
      
      // Handle the nested structure: data.output_data.findings (Website Vulnerability Scanner)
      const outputData = data.data || data;
      let rawFindings: any[] = [];
      
      if (outputData.output_data?.findings && Array.isArray(outputData.output_data.findings)) {
        // Website Vulnerability Scanner format: { output_type: "finding_list", output_data: { findings: [...] } }
        rawFindings = outputData.output_data.findings;
      } else if (Array.isArray(outputData)) {
        // Direct array of findings
        rawFindings = outputData;
      } else if (outputData.items && Array.isArray(outputData.items)) {
        // Items array structure
        rawFindings = outputData.items;
      } else if (outputData.vulnerabilities && Array.isArray(outputData.vulnerabilities)) {
        // Vulnerabilities array structure
        rawFindings = outputData.vulnerabilities;
      } else if (outputData.findings && Array.isArray(outputData.findings)) {
        // Direct findings array structure
        rawFindings = outputData.findings;
      } else if (typeof outputData === 'object') {
        // Try to extract findings from nested structure
        for (const key of Object.keys(outputData)) {
          const value = outputData[key];
          if (Array.isArray(value) && value.length > 0) {
            rawFindings = value;
            break;
          }
        }
      }
      
      console.log('[Pentest-Tools] Found', rawFindings.length, 'raw findings');
      findings = rawFindings.map((item: any, idx: number) => this.parseOutputItem(item, idx));

      return { success: true, data: findings };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unbekannter Fehler' 
      };
    }
  }

  private parseOutputItem(item: any, index: number): Finding {
    // Determine severity from various possible fields
    // risk_level: 0=info, 1=low, 2=medium, 3=high, 4=critical
    let severity: 'critical' | 'high' | 'medium' | 'low' | 'info' = 'info';
    
    if (typeof item.risk_level === 'number') {
      // Website Vulnerability Scanner uses risk_level (0-4)
      switch (item.risk_level) {
        case 4: severity = 'critical'; break;
        case 3: severity = 'high'; break;
        case 2: severity = 'medium'; break;
        case 1: severity = 'low'; break;
        default: severity = 'info';
      }
    } else if (item.severity) {
      const sev = String(item.severity).toLowerCase();
      if (sev === 'critical' || sev === 'high' || sev === 'medium' || sev === 'low' || sev === 'info') {
        severity = sev as any;
      }
    } else if (item.risk) {
      const risk = String(item.risk).toLowerCase();
      if (risk.includes('critical')) severity = 'critical';
      else if (risk.includes('high')) severity = 'high';
      else if (risk.includes('medium')) severity = 'medium';
      else if (risk.includes('low')) severity = 'low';
    } else if (item.cvss_score || item.cvss || item.cvssv3) {
      const cvss = parseFloat(item.cvss_score || item.cvssv3 || item.cvss);
      if (cvss >= 9.0) severity = 'critical';
      else if (cvss >= 7.0) severity = 'high';
      else if (cvss >= 4.0) severity = 'medium';
      else if (cvss > 0) severity = 'low';
    }

    // Extract affected URL from vuln_evidence if available
    let affectedUrl = item.affected_url || item.url || item.target || item.path;
    if (!affectedUrl && item.vuln_evidence?.data?.rows) {
      // Try to get URL from evidence table
      const rows = item.vuln_evidence.data.rows;
      if (rows.length > 0 && rows[0].length > 0) {
        affectedUrl = rows[0][0];
      }
    }

    // Get CWE ID
    const cweId = item.cwe_id || item.cwe || (item.cwe_list?.length > 0 ? item.cwe_list[0] : undefined);

    return {
      id: String(item.id || index),
      title: item.title || item.name || item.vulnerability || item.finding || item.issue || `Finding #${index + 1}`,
      severity,
      description: item.description || item.vuln_description || item.details || item.summary || item.info,
      solution: item.solution || item.remediation || item.recommendation || item.fix,
      reference: item.reference || item.references || (Array.isArray(item.references) && item.references.length > 0 ? item.references[0] : undefined),
      cvss_score: item.cvss_score || item.cvssv3 || item.cvss ? parseFloat(item.cvss_score || item.cvssv3 || item.cvss) : undefined,
      cwe_id: cweId,
      affected_url: affectedUrl,
    };
  }

  async stopScan(scanId: string): Promise<ApiResponse<void>> {
    if (!(await this.isConfigured())) {
      return { success: false, error: 'API Token nicht konfiguriert' };
    }

    try {
      const response = await fetch(`${API_BASE_URL}/scans/${scanId}/stop`, {
        method: 'POST',
        headers: await this.getHeaders(),
      });

      if (!response.ok) {
        const errorData = await response.json() as any;
        return { 
          success: false, 
          error: errorData.message || `HTTP ${response.status}` 
        };
      }

      return { success: true };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unbekannter Fehler' 
      };
    }
  }

  getAvailableTools(): { id: number; name: string }[] {
    return Object.entries(TOOL_NAMES).map(([id, name]) => ({
      id: parseInt(id),
      name,
    }));
  }

  getScanTypes(): { id: string; name: string }[] {
    return [
      { id: 'light', name: 'Light Scan (schnell)' },
      { id: 'full_new', name: 'Full Scan (gründlich)' },
      { id: 'quick', name: 'Quick Scan (sehr schnell)' },
    ];
  }

  // ============== POLLY TARGET MANAGEMENT ==============

  getPollyUrl(requestHost?: string): string | null {
    // Priority 1: Environment variable
    if (process.env.PUBLIC_BASE_URL) {
      return this.normalizeUrl(process.env.PUBLIC_BASE_URL);
    }
    if (process.env.BASE_URL) {
      return this.normalizeUrl(process.env.BASE_URL);
    }
    if (process.env.REPLIT_DEV_DOMAIN) {
      return `https://${process.env.REPLIT_DEV_DOMAIN}`;
    }
    
    // Priority 2: Request host header (for deployed apps)
    if (requestHost && !requestHost.includes('localhost')) {
      return `https://${requestHost}`;
    }
    
    return null;
  }

  private normalizeUrl(url: string): string {
    let normalized = url.trim();
    if (!normalized.startsWith('http://') && !normalized.startsWith('https://')) {
      normalized = `https://${normalized}`;
    }
    // Remove trailing slash
    return normalized.replace(/\/$/, '');
  }

  async getPollyTargetInfo(requestHost?: string): Promise<PollyTargetInfo> {
    const pollyUrl = this.getPollyUrl(requestHost);
    
    if (!pollyUrl) {
      return {
        configured: false,
        error: 'Polly-URL konnte nicht ermittelt werden. Bitte PUBLIC_BASE_URL Umgebungsvariable setzen.',
      };
    }

    try {
      const setting = await storage.getSetting('pentest_tools_polly_target');
      if (setting && setting.value) {
        const targetData = setting.value as { 
          url: string; 
          targetId: number; 
          workspaceId?: number;
          lastSynced: string;
        };
        
        // Check if URL changed
        if (targetData.url === pollyUrl) {
          return {
            configured: true,
            url: pollyUrl,
            targetId: targetData.targetId,
            workspaceId: targetData.workspaceId,
            lastSynced: targetData.lastSynced,
          };
        }
        // URL changed, need to resync
      }
    } catch (error) {
      console.error('Error loading Polly target info:', error);
    }

    return {
      configured: false,
      url: pollyUrl,
      error: 'Target noch nicht bei Pentest-Tools angelegt',
    };
  }

  async syncPollyTarget(requestHost?: string): Promise<{ success: boolean; targetInfo?: PollyTargetInfo; error?: string }> {
    if (!(await this.isConfigured())) {
      return { success: false, error: 'API Token nicht konfiguriert' };
    }

    const pollyUrl = this.getPollyUrl(requestHost);
    if (!pollyUrl) {
      return { success: false, error: 'Polly-URL konnte nicht ermittelt werden' };
    }

    try {
      // First, check if target already exists
      const existingTarget = await this.findTargetByUrl(pollyUrl);
      
      let targetId: number;
      let workspaceId: number | undefined;

      if (existingTarget) {
        targetId = existingTarget.id;
        workspaceId = existingTarget.workspace_id;
      } else {
        // Create new target
        const createResult = await this.createTarget(pollyUrl, 'Polly Security Scan Target');
        if (!createResult.success || !createResult.targetId) {
          return { success: false, error: createResult.error || 'Target konnte nicht erstellt werden' };
        }
        targetId = createResult.targetId;
        workspaceId = createResult.workspaceId;
      }

      // Save to database
      const targetData = {
        url: pollyUrl,
        targetId,
        workspaceId,
        lastSynced: new Date().toISOString(),
      };

      await storage.setSetting({
        key: 'pentest_tools_polly_target',
        value: targetData,
        description: 'Polly target configuration for Pentest-Tools',
      });

      return {
        success: true,
        targetInfo: {
          configured: true,
          url: pollyUrl,
          targetId,
          workspaceId,
          lastSynced: targetData.lastSynced,
        },
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unbekannter Fehler',
      };
    }
  }

  // Find all targets that are Replit URLs (for historical Polly scans)
  private async getAllPollyRelatedTargets(): Promise<number[]> {
    try {
      const response = await fetch(`${API_BASE_URL}/targets?limit=1000`, {
        method: 'GET',
        headers: await this.getHeaders(),
      });

      if (!response.ok) {
        return [];
      }

      const data = await response.json() as any;
      const targets = data.data || data || [];
      
      // Find all targets that look like Replit URLs
      const replitTargetIds: number[] = [];
      for (const target of targets) {
        const name = (target.name || '').toLowerCase();
        // Match Replit URL patterns
        if (name.includes('.replit.dev') || 
            name.includes('.replit.app') ||
            name.includes('.repl.co') ||
            name.includes('replit')) {
          replitTargetIds.push(target.id);
        }
      }
      
      console.log('[Pentest-Tools] Found Polly-related targets:', replitTargetIds);
      return replitTargetIds;
    } catch (error) {
      console.error('[Pentest-Tools] Error getting Polly-related targets:', error);
      return [];
    }
  }

  private async findTargetByUrl(url: string, requireUrlType: boolean = true): Promise<PentestTarget | null> {
    try {
      const response = await fetch(`${API_BASE_URL}/targets?limit=1000`, {
        method: 'GET',
        headers: await this.getHeaders(),
      });

      if (!response.ok) {
        return null;
      }

      const data = await response.json() as any;
      const targets = data.data || data || [];
      
      // Find target matching our URL - prefer exact URL match (type 'url')
      const normalizedUrl = this.normalizeUrl(url);
      
      // First try to find exact URL-type match (includes protocol)
      const urlTypeMatch = targets.find((t: PentestTarget) => {
        return t.type === 'url' && t.name.toLowerCase() === normalizedUrl.toLowerCase();
      });
      
      if (urlTypeMatch) {
        console.log('[Pentest-Tools] Found URL-type target:', urlTypeMatch.id, urlTypeMatch.name);
        return urlTypeMatch;
      }
      
      // If not requiring URL type, also check hostname matches
      if (!requireUrlType) {
        const hostnameMatch = targets.find((t: PentestTarget) => {
          const searchHostname = normalizedUrl.toLowerCase().replace('https://', '').replace('http://', '');
          return t.name.toLowerCase() === searchHostname;
        });
        
        if (hostnameMatch) {
          console.log('[Pentest-Tools] Found hostname-type target:', hostnameMatch.id, hostnameMatch.name);
          return hostnameMatch;
        }
      }

      return null;
    } catch (error) {
      console.error('Error finding target:', error);
      return null;
    }
  }

  private async createTarget(url: string, description?: string): Promise<{ success: boolean; targetId?: number; workspaceId?: number; error?: string }> {
    try {
      // Use full URL as target name - this creates a "url" type target
      // which is required for Website Vulnerability Scanner and similar tools
      const targetName = url;

      console.log('[Pentest-Tools] Creating target with name:', targetName);

      const response = await fetch(`${API_BASE_URL}/targets`, {
        method: 'POST',
        headers: await this.getHeaders(),
        body: JSON.stringify({
          name: targetName,
          description: description || 'Polly Security Scan Target',
        }),
      });

      const responseText = await response.text();
      console.log('[Pentest-Tools] Create target response:', response.status, responseText.substring(0, 200));

      if (!response.ok) {
        // Handle 409 conflict (target already exists) or other errors
        // Always try to find existing target first
        const existing = await this.findTargetByUrl(url);
        if (existing) {
          console.log('[Pentest-Tools] Found existing target after create attempt:', existing.id);
          return { success: true, targetId: existing.id, workspaceId: existing.workspace_id };
        }
        
        // If no existing target found, return the error
        let errorMessage = `HTTP ${response.status}`;
        try {
          const errorData = JSON.parse(responseText);
          errorMessage = errorData.message || errorData.error || errorMessage;
        } catch (e) {}
        
        return { success: false, error: errorMessage };
      }

      let data: any;
      try {
        data = JSON.parse(responseText);
      } catch (e) {
        return { success: false, error: 'Invalid JSON response' };
      }
      
      const targetId = data.data?.id || data.id;
      
      // Get the full target to retrieve workspace_id
      const fullTarget = await this.findTargetByUrl(url);
      
      return { 
        success: true, 
        targetId,
        workspaceId: fullTarget?.workspace_id,
      };
    } catch (error) {
      // Even on error, try to find existing target
      const existing = await this.findTargetByUrl(url);
      if (existing) {
        console.log('[Pentest-Tools] Found existing target after error:', existing.id);
        return { success: true, targetId: existing.id, workspaceId: existing.workspace_id };
      }
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unbekannter Fehler',
      };
    }
  }

  async startPollyScan(
    toolId: number = TOOL_IDS.WEBSITE_SCANNER,
    scanType: string = SCAN_TYPES.LIGHT,
    requestHost?: string
  ): Promise<ScanStartResponse> {
    if (!(await this.isConfigured())) {
      return { success: false, error: 'API Token nicht konfiguriert' };
    }

    // Get or sync Polly target
    let targetInfo = await this.getPollyTargetInfo(requestHost);
    
    if (!targetInfo.configured || !targetInfo.targetId) {
      // Try to sync target first
      const syncResult = await this.syncPollyTarget(requestHost);
      if (!syncResult.success || !syncResult.targetInfo) {
        return { success: false, error: syncResult.error || 'Polly-Target konnte nicht konfiguriert werden' };
      }
      targetInfo = syncResult.targetInfo;
    }

    if (!targetInfo.targetId) {
      return { success: false, error: 'Polly-Target ID nicht verfügbar - bitte Target synchronisieren' };
    }

    console.log('[Pentest-Tools] Starting Polly scan with target ID:', targetInfo.targetId, 'URL:', targetInfo.url);

    // Start scan with the Polly target ID
    return this.startScan(targetInfo.targetId, toolId, scanType);
  }
}

export const pentestToolsService = new PentestToolsService();
